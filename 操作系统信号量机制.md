[toc]
# 操作系统
操作系统功能：管理计算机资源，向用户提供使用接口，
按四个模块来讲：
1. 处理机管理
2. 内存管理
3. 文件管理
4. 设备管理

## 进程---处理机管理
操作系统的特征是并发、共享、虚拟、异步。其中最基本的特征是并发和共享，并发是多道批处理程序的基础，用户感觉到一台机器是可以运行多个应用程序的。中断是引起进程切换的途径，这些都是交给操作系统来完成的，其中跟资源相关的操作都是在核心态下完成的

### 整型信号量
```python
S = 1     # S表示资源数，比如说一台打印机资源

def P():
    global S
    while S<=0: pass #当资源为空时，让进程等待
    S -= 1

def V():
    global S
    S += 1
```
在操作系统中，P、V操作都是原语，执行是“一气呵成的”
==缺陷==：不满足“让权等待”的原则，就是说当一个进程需要的资源数小于或等于零时，该进程会进入while循环，一直等待，直到该进程的时间片用完（其实最好的应该是资源不满足时应该主动阻塞，让出处理机，记录性信号量就实现了这一功能）

### 记录型信号量
```python
class semaphore:
    def __init__(self):
        self.value  #剩余资源数
        self.queue  #等待队列，用于存储被阻塞的进程
s = semaphore()

def P():
    s.value -= 1
    # s.value为负数时，它的绝对值就表示queue的长度，也就是被阻塞的进程的个数
    # 减了1后小于0，说明之前是s.value<1，资源已经没有了
    if s.value<0:
        #让当前进程阻塞，让出处理机，添加到阻塞队列中
        block(s.queue)

def V():
    s.value += 1
    # 加了1后小于等于0， 说明之前是s.value<=-1，
    # 即至少有一个进程在queue中，所以需要使用wakeup命令使其中的一个进程从阻塞态变为就绪态
    if s.value<=0:
        wakeup(s.queue)
```
### 用记录型信号量实现进程互斥
进程互斥：不同进程对同一临界资源的访问不能同时发生
临界区：访问临界资源的代码
```python
mutex = 1 #初始值设为1  
def process1():
    P(mutex)
    临界区代码
    V(mutex)

def process2():
    P(mutex)
    临界区代码
    V(mutex)
```
### 用记录型信号量实现进程同步
由于操作系统的并发性，进程里面的语句执行不是“一气呵成”的，不同进程的语句执行顺序是不确定的
如果要让进程按照一定顺序推进
可以通过记录型的信号量来实现进程同步
```python
# process1，process2并发执行，代码的执行顺序是不确定的
def process1():
    代码1
    代码2
    代码3

def process2():
    代码4
    代码5
    代码6
```

```python
# 如果我们让代码4的执行是基于代码1和代码2的，
# 我们就必须保证代码4一定是在代码2执行之后才能执行的
# 用信号量机制实现进程同步
# 在“前操作”之后执行V(S)
# 在“后操作”之前执行P(S)
semaphore S = 0 #初始值设为0
def process1():
    代码1
    代码2
    V(S)
    代码3

def process2():
    P(S)
    代码4
    代码5
    代码6
```

### 用记录型信号量解决生产者消费者问题
```python
# 互斥信号量，用于生产者/消费者线程互斥地访问物品队列
semaphore mutex = 1
# 同步信号量，表示物品队列的空位数，只有有空位时，生产者才能放物品，否则阻塞生产者
semaphore empty = n
# 同步信号量，表示物品的数目，只有有物品时，消费者才能取物品，否则阻塞消费者
semaphore full = 0

def producer():
    while 1:
        生产一个产品
        P(empty)
        P(mutex)
        放入物品
        V(mutex)
        V(full)

def consumer():
    while 1:
        P(full)
        P(mutex)
        消费一个物品
        V(mutex)
        V(empty)
        使用产品
```

### 管程
管程用于处理进程互斥、同步的问题。
比如用管程定义生产者消费者问题里面的物品缓冲区，定义放入物品、取走物品的操作
然后生产者消费者进程使用管程定义的操作，由于管程内的操作最多只能由一个进程操控，从而处理进程互斥

### 死锁
在并发环境下，各进程因为竞争资源而造成的一种互相等待对方资源，导致所有进程都无法向前推进的现象。处于死锁的进程一定处于==阻塞态==。
比如说，哲学者进餐问题，每个哲学者都拿起身边的一只筷子，由于每个哲学家都没法拿到第二根筷子，每个哲学家都进入阻塞状态

容易混淆的概念：
1. 饥饿：某一个进程长期得不到资源而一直处于阻塞态或就绪态（得不到处理机资源）。
2. 死循环：进程处于运行态，像while(1)一样

死锁的处理策略：
1. 预防死锁，破坏死锁的四个必要条件
2. 避免死锁，银行家算法
3. 死锁的检测和解除，

##  内存管理
功能：
1. 分配与回收
2. 虚拟内存
3. 逻辑地址到物理地址的转换
4. 内存保护，内存段独立
### 将程序装入内存--完成逻辑地址到物理地址的转换
编译器编译的程序里面的数据以逻辑地址的形式的，cpu在取数据时需要将逻辑地址转化为物理地址
三种装入方式：
1. 绝对装入：编译器提前知道程序要放在内存的什么位置，直接事先将逻辑地址转化为物理地址，逻辑地址到物理地址的转化是==编译器完成==的，此时内存中==存物理地址==
2. 静态重定位，一次性把整段程序装入内存，逻辑地址到物理地址的转换是==装入程序==完成的，装入之后位置不再更改，不能申请新的内存，此时内存存的也是==物理地址==
3. 动态重定位，内存中的数据是以==逻辑地址==的形式的，逻辑地址到物理地址的转化是由==重定位寄存器==完成的，是在程序运行的时候执行的

## 分配与回收
1. 连续分配
    1. 单一连续分配，单道批处理用的
    2. 固定分区分配，内存被划分为一个个分区
    3. 动态分区分配，动态地为内存分配大小合适的分区
       操作系统会设置==空闲分区表==来记录空闲的内存，长这样：
       ![](https://img-blog.csdnimg.cn/20210522001102498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTE4NzQ0,size_16,color_FFFFFF,t_70)
        1. 首次适应算法
        2. 最佳适应算法，优先使用更小的空闲区，缺点：有很多小碎片
        3. 最坏适应算法，优先使用更大的空闲区，缺点：“大进程”可能没有坑位了
        4. 邻近适应算法，首次适应算法改进，每次从上一个查找结束位置开始查找
   连续的分配方式，内存利用率较低
2. 离散分配
   1. 分页存储：将进程分为若干相等的页，每个都有一个页号。将内存分为若干相等的块，每个都有一个块号。块和页的大小是相等的。操作系统为每个进程创建一个页表，实现页号到块号的转换。
      1. 优点：内存利用率高，不会产生碎片
      2. 缺点：逻辑性不好，不容易实现内存信息的共享和保护
   2. 分段存储：将进程分为大小不相等的段，每个都有一个段号。操作系统为每个进程创建一个段表，实现段号到物理地址的转换。分段的主要目的是更好地满足程序员的要求，一个段通常对应一个逻辑处理模块。
      1. 优点：逻辑性好，容易实现内存信息的共享和保护
      2. 会产生碎片
   3. 段页式存储：先对程序分段，再对每一段分页，内存分为若干相等的块，页的大小和块的大小是相等的