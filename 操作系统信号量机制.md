[toc]
# 进程
操作系统的特征是并发、共享、虚拟、异步。其中最基本的特征是并发和共享，并发是多道批处理程序的基础，用户感觉到一台机器是可以运行多个应用程序的。中断是引起进程切换的途径，这些都是交给操作系统来完成的，其中跟资源相关的操作都是在核心态下完成的
## 整型信号量


```python
S = 1     # S表示资源数，比如说一台打印机资源

def P():
    global S
    while S<=0: pass #当资源为空时，让进程等待
    S -= 1

def V():
    global S
    S += 1
```
在操作系统中，P、V操作都是原语，执行是“一气呵成的”
==缺陷==：不满足“让权等待”的原则，就是说当一个进程需要的资源数小于或等于零时，该进程会进入while循环，一直等待，直到该进程的时间片用完（其实最好的应该是资源不满足时应该主动阻塞，让出处理机，记录性信号量就实现了这一功能）

## 记录型信号量
```python
class semaphore:
    def __init__(self):
        self.value  #剩余资源数
        self.queue  #等待队列，用于存储被阻塞的进程
s = semaphore()

def P():
    s.value -= 1
    # s.value为负数时，它的绝对值就表示queue的长度，也就是被阻塞的进程的个数
    # 减了1后小于0，说明之前是s.value<1，资源已经没有了
    if s.value<0:
        #让当前进程阻塞，让出处理机，添加到阻塞队列中
        block(s.queue)

def V():
    s.value += 1
    # 加了1后小于等于0， 说明之前是s.value<=-1，
    # 即至少有一个进程在queue中，所以需要使用wakeup命令使其中的一个进程从阻塞态变为就绪态
    if s.value<=0:
        wakeup(s.queue)
```
## 用记录型信号量实现进程互斥
进程互斥：不同进程对同一临界资源的访问不能同时发生
临界区：访问临界资源的代码
```python
mutex = 1 #初始值设为1  
def process1():
    P(mutex)
    临界区代码
    V(mutex)

def process2():
    P(mutex)
    临界区代码
    V(mutex)
```
## 用记录型信号量实现进程同步
由于操作系统的并发性，进程里面的语句执行不是“一气呵成”的，不同进程的语句执行顺序是不确定的
如果要让进程按照一定顺序推进
可以通过记录型的信号量来实现进程同步
```python
# process1，process2并发执行，代码的执行顺序是不确定的
def process1():
    代码1
    代码2
    代码3

def process2():
    代码4
    代码5
    代码6
```

```python
# 如果我们让代码4的执行是基于代码1和代码2的，
# 我们就必须保证代码4一定是在代码2执行之后才能执行的
# 用信号量机制实现进程同步
# 在“前操作”之后执行V(S)
# 在“后操作”之前执行P(S)
semaphore S = 0 #初始值设为0
def process1():
    代码1
    代码2
    V(S)
    代码3

def process2():
    P(S)
    代码4
    代码5
    代码6
```

## 用记录型信号量解决生产者消费者问题
```python
# 互斥信号量，用于生产者/消费者线程互斥地访问物品队列
semaphore mutex = 1
# 同步信号量，表示物品队列的空位数，只有有空位时，生产者才能放物品，否则阻塞生产者
semaphore empty = n
# 同步信号量，表示物品的数目，只有有物品时，消费者才能取物品，否则阻塞消费者
semaphore full = 0

def producer():
    while 1:
        生产一个产品
        P(empty)
        P(mutex)
        放入物品
        V(mutex)
        V(full)

def consumer():
    while 1:
        P(full)
        P(mutex)
        消费一个物品
        V(mutex)
        V(empty)
        使用产品
```